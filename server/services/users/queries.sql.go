// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package users

import (
	"context"

	"github.com/google/uuid"
)

const deleteAuthor = `-- name: DeleteAuthor :exec
DELETE FROM "user"
WHERE id = $1
`

func (q *Queries) DeleteAuthor(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteAuthorStmt, deleteAuthor, id)
	return err
}

const getorCreateUserByAuthProviderId = `-- name: GetorCreateUserByAuthProviderId :one
INSERT INTO "user" (
  auth_provider_id, auth_specific_id
) VALUES (
  $1, $2
)
ON CONFLICT(auth_provider_id, auth_specific_id)
DO UPDATE SET auth_provider_id=EXCLUDED.auth_provider_id
RETURNING id, auth_provider_id, auth_specific_id
`

type GetorCreateUserByAuthProviderIdParams struct {
	AuthProviderID string `json:"authProviderID"`
	AuthSpecificID string `json:"authSpecificID"`
}

// TODO: perf impact of doing this
func (q *Queries) GetorCreateUserByAuthProviderId(ctx context.Context, arg GetorCreateUserByAuthProviderIdParams) (User, error) {
	row := q.queryRow(ctx, q.getorCreateUserByAuthProviderIdStmt, getorCreateUserByAuthProviderId, arg.AuthProviderID, arg.AuthSpecificID)
	var i User
	err := row.Scan(&i.ID, &i.AuthProviderID, &i.AuthSpecificID)
	return i, err
}
